<객체지향(Object Oriented Programming) : OOP>

객체 : 세상에 존재하는 모든 것을 뜻하며, 프로그래밍에서 속성과 기능을 가지는 프로그램 단위

[현실의 객체] : <사람>                    <TV>                      <승용차>
              * 속성 : 키, 몸무게         * 속성 : 채널, 사운드        * 속성 : 바퀴, 체인, 엔진
              * 기능 : 의사, 프로그래머    * 기능 : 미디어 송출         * 기능 : 이동수단

[프로그래밍에서 객체] : <날씨 프로그램>                        <계산기>
                     * 속성 : 온도, 미세먼지, 강수확률       * 속성 : + - * / ...
                     * 기능 : 날씨 예보                    * 기능 : 연산기능

Garbage Collector(GC) : 메모리를 정리하는 JAVA의 메모리관리도구

클래스 : 객체를 생성하기 위한 틀로 모든 객체는 클래스로부터 생성됨.(객체를 생성하기 위해 변수와 메소드를 정의하는 공간)
[자동차 클래스] - 속성 : 색상, 바퀴, 기능 : 배기량
자동차 클래스 복제 -> 자동차1 객체(색상: 검정, 바퀴 : 광폭, 기능 : 2500cc 배기량), 경유차 / 자동차2 객체(색상 : 은색, 바퀴 : 일반, 기능 : 배기량(3000cc), 전기차


클래스의 구성요소 : 속성(멤버변수), 기능(메서드)
예) 자전거 클래스 - 속성(멤버변수) : 안장, 핸들, 바구니, 기어, 페달, 바퀴
               - 기능(메서드) : 기어 변속, 가속, 브레이크, 달리기


객체지향을 사용하는 이유 : 모듈화, 재사용성 등등

<객체와 메모리>
1. 객체는 메모리에서 동적으로 생성되고, 객체가 더 이상필요없게되면 GC(Garbage Collector)에 의해서 제거된다.
ex) TestClass testclass = new TestClass(); -> 여기서 testclass는 TestClass의 래퍼런스(참조)이다. (동적생성)
2. 래퍼런스란 생성한 객체의 주소를 변수에 저장하는 것을 의미한다.
3. 생성자를 따로 선언하지 않아도 메모리상에서 자동으로 만들어준다.
4. 자료형이 같아도 다른 공간에 존재하는 객체는 다른객체이다(래퍼런스가 다르게때문)
ex) [객체1] [객체1] [객체1]
      ↑       ↑      ↑
    [주소]   [주소]  [주소]
※ 같은 객체를 여러번 선언해도 메모리상으로 다른공간에 저장하기때문에 같은 객체지만 같다고 볼 수 없다.
5. 래퍼런스에 null이 저장되면 연결이 끊기고 더 이상 사용할 수 없다.

<생성자와 소멸자 그리고 This 키워드>
생성자 : 객체가 생성될 떄 생성되는 키워드
소멸자 : 객체가 메모리에서 제거 될 떄 finalize() 메서드가 호출 된다.
System.gc(); -> 가비지 컬렉터를 호출하는 메서드, 메서드를 호출해서 사용하는데 사용시점에 바로 작동하는것이 아닌, 최대한 빠른 시점에 작동하도록 유도하는 것이다.(실행시점을 알 수 없음)
※ 메모리를 직접관리하는 경우가 드물어 사용하는 경우는 많지않음
this : 현재 객체를 가르키는 키워드(A라는 클래스의 메서드를 호출할 떄 this를 사용하면 A클래스의 전역변수를 가르키는 것)
ex)
private int x; // 전역변수
private int y;
public void test(int x, int y) { // 지역변수
    this.x = x; // 전역변수 x에 지역변수 y값을 대입(초기화)
    this.y = y;
}


<패키지와 static>
패키지 : 클래스를 폴더형식으로 관리한 것을 패키지라고 한다.(자바 클래스들을 여러 이름공간으로 정리한 것)
패키지 네이밍 : 1. 패키지 이름은 패키지에 속해 있는 클래스가 최대한 다른 클래스와 중복되는 것을 방지하도록 만든다.
              2. 패키지 이름은 일반적으로 도메인을 거꾸로 이용한다.
              3. 개발 중에 패키지의 이름과 구조는 변경될 수 있다.
              4. 패키지 이름만 보고도 해당 패키지 안에 있는 클래스가 어떤 속성과 기능을 가지고 있는지 예상이 될 수 있도록 만든다.


※ 다른패키지에 있는 클래스를 사용하고 싶다면 import를 이용한다.
ex) test패키지에서 main의 Flag class를 사용하고 싶을 떄 -> import com.java.main.Flag;
※ 해당 패키지 안에 있는 모든 클래스를 사용하고자 할때는 다음과 같이 사용한다.
import com.java.main.*; (* : 에스터리크)

정적(static) : 고정된이란 의미를 가지고있고, 정적멤버혹은 클래스 멤버로가 칭한다, 정적 필드(메소드)는 객체에 소속된 멤버가 아닌 클래스에 고정된 멤버로 클래스
로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리 되기 떄문에 클래스의 로딩이 끝나는 즉시 사용이 가능하다.(Heap영역이 아닌 static 영역) 따라서 가비지컬렉터의 영향을 받지않음
ex) A라는 클래스에 test라는 static 정적 메서드가 있다고 가정했을 때 new를 이용해 초기화 하지않고 A.test(); 처럼 입력하여 호출이 가능하다.(유틸리티 함수를 만들 떄 유용)

클래스의 속성과 메서드에 static 키워드를 사용하면 어디서나 속성과 메서드를 공유할 수 있다.
static으로 설정할 시 별도의 공간으로 관리하게 되고, 객체와 상관없이 공통으로 사용할 수 있다.
ex) 객체1과 객체2가 static으로 선언된 a라는 값을 접근할 수 있음.



<데이터 은닉>
멤버변수(속성)은 주로 private 접근제어자를 이용해 외부로부터 데이터가 변질되는 것을 막는다.
※ 속성은 쉽게 접근할 수 있게하는것은 바람직한 상황은 아님
멤머 변수를 외부에서 변경할 수 있도록 하려면 getter와 setter를 이용한다.
※ 멤버변수를 은닉하여 사용할 경우 데이터 변환에 대해서 방어로직을 작성할 수 있다.
ex) a라는 멤버변수는 setter를 이용하여 데이터를 저장할 떄 50미만일 경우만 set할 수 있게 한다.
+ 객체의 무결성 보장 및 유효성검증을 위해 getter와 setter를 사용하는 것임.
getter는 프로퍼티(속성)을 복사하여 리턴하기 때문에 무결성을 지킬 수 있음.





