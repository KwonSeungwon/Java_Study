<객체지향(Object Oriented Programming) : OOP>

객체 : 세상에 존재하는 모든 것을 뜻하며, 프로그래밍에서 속성과 기능을 가지는 프로그램 단위

[현실의 객체] : <사람>                    <TV>                      <승용차>
              * 속성 : 키, 몸무게         * 속성 : 채널, 사운드        * 속성 : 바퀴, 체인, 엔진
              * 기능 : 의사, 프로그래머    * 기능 : 미디어 송출         * 기능 : 이동수단

[프로그래밍에서 객체] : <날씨 프로그램>                        <계산기>
                     * 속성 : 온도, 미세먼지, 강수확률       * 속성 : + - * / ...
                     * 기능 : 날씨 예보                    * 기능 : 연산기능

Garbage Collector(GC) : 메모리를 정리하는 JAVA의 메모리관리도구

클래스 : 객체를 생성하기 위한 틀로 모든 객체는 클래스로부터 생성됨.(객체를 생성하기 위해 변수와 메소드를 정의하는 공간)
[자동차 클래스] - 속성 : 색상, 바퀴, 기능 : 배기량
자동차 클래스 복제 -> 자동차1 객체(색상: 검정, 바퀴 : 광폭, 기능 : 2500cc 배기량), 경유차 / 자동차2 객체(색상 : 은색, 바퀴 : 일반, 기능 : 배기량(3000cc), 전기차


클래스의 구성요소 : 속성(멤버변수), 기능(메서드)
예) 자전거 클래스 - 속성(멤버변수) : 안장, 핸들, 바구니, 기어, 페달, 바퀴
               - 기능(메서드) : 기어 변속, 가속, 브레이크, 달리기


객체지향을 사용하는 이유 : 모듈화, 재사용성 등등

<객체와 메모리>
1. 객체는 메모리에서 동적으로 생성되고, 객체가 더 이상필요없게되면 GC(Garbage Collector)에 의해서 제거된다.
ex) TestClass testclass = new TestClass(); -> 여기서 testclass는 TestClass의 래퍼런스(참조)이다. (동적생성)
2. 래퍼런스란 생성한 객체의 주소를 변수에 저장하는 것을 의미한다.
3. 생성자를 따로 선언하지 않아도 메모리상에서 자동으로 만들어준다.
4. 자료형이 같아도 다른 공간에 존재하는 객체는 다른객체이다(래퍼런스가 다르게때문)
ex) [객체1] [객체1] [객체1]
      ↑       ↑      ↑
    [주소]   [주소]  [주소]
※ 같은 객체를 여러번 선언해도 메모리상으로 다른공간에 저장하기때문에 같은 객체지만 같다고 볼 수 없다.
5. 래퍼런스에 null이 저장되면 연결이 끊기고 더 이상 사용할 수 없다.

<생성자와 소멸자 그리고 This 키워드>
생성자 : 객체가 생성될 떄 생성되는 키워드
소멸자 : 객체가 메모리에서 제거 될 떄 finalize() 메서드가 호출 된다.
System.gc(); -> 가비지 컬렉터를 호출하는 메서드, 메서드를 호출해서 사용하는데 사용시점에 바로 작동하는것이 아닌, 최대한 빠른 시점에 작동하도록 유도하는 것이다.(실행시점을 알 수 없음)
※ 메모리를 직접관리하는 경우가 드물어 사용하는 경우는 많지않음
this : 현재 객체를 가르키는 키워드(A라는 클래스의 메서드를 호출할 떄 this를 사용하면 A클래스의 전역변수를 가르키는 것)
ex)
private int x; // 전역변수
private int y;
public void test(int x, int y) { // 지역변수
    this.x = x; // 전역변수 x에 지역변수 y값을 대입(초기화)
    this.y = y;
}


<패키지와 static>
패키지 : 클래스를 폴더형식으로 관리한 것을 패키지라고 한다.(자바 클래스들을 여러 이름공간으로 정리한 것)
패키지 네이밍 : 1. 패키지 이름은 패키지에 속해 있는 클래스가 최대한 다른 클래스와 중복되는 것을 방지하도록 만든다.
              2. 패키지 이름은 일반적으로 도메인을 거꾸로 이용한다.
              3. 개발 중에 패키지의 이름과 구조는 변경될 수 있다.
              4. 패키지 이름만 보고도 해당 패키지 안에 있는 클래스가 어떤 속성과 기능을 가지고 있는지 예상이 될 수 있도록 만든다.


※ 다른패키지에 있는 클래스를 사용하고 싶다면 import를 이용한다.
ex) test패키지에서 main의 Flag class를 사용하고 싶을 떄 -> import com.java.main.Flag;
※ 해당 패키지 안에 있는 모든 클래스를 사용하고자 할때는 다음과 같이 사용한다.
import com.java.main.*; (* : 에스터리크)

정적(static) : 고정된이란 의미를 가지고있고, 정적멤버혹은 클래스 멤버로가 칭한다, 정적 필드(메소드)는 객체에 소속된 멤버가 아닌 클래스에 고정된 멤버로 클래스
로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리 되기 떄문에 클래스의 로딩이 끝나는 즉시 사용이 가능하다.(Heap영역이 아닌 static 영역) 따라서 가비지컬렉터의 영향을 받지않음
ex) A라는 클래스에 test라는 static 정적 메서드가 있다고 가정했을 때 new를 이용해 초기화 하지않고 A.test(); 처럼 입력하여 호출이 가능하다.(유틸리티 함수를 만들 떄 유용)

클래스의 속성과 메서드에 static 키워드를 사용하면 어디서나 속성과 메서드를 공유할 수 있다.
static으로 설정할 시 별도의 공간으로 관리하게 되고, 객체와 상관없이 공통으로 사용할 수 있다.
ex) 객체1과 객체2가 static으로 선언된 a라는 값을 접근할 수 있음.

중요!
인스턴스 변수 : 인스턴스(객체)가 생성되었을 때, 인스턴스 안에 존재하는 변수
클래스 변수(static 변수) : 인스턴스의 생성과 상관없이 클래스 안에 존재하는 변수
public class test {
    int a; // 인스턴스 변수
    static int b; //클래스 변수}


<데이터 은닉>
멤버변수(속성)은 주로 private 접근제어자를 이용해 외부로부터 데이터가 변질되는 것을 막는다.
※ 속성은 쉽게 접근할 수 있게하는것은 바람직한 상황은 아님
멤머 변수를 외부에서 변경할 수 있도록 하려면 getter와 setter를 이용한다.
※ 멤버변수를 은닉하여 사용할 경우 데이터 변환에 대해서 방어로직을 작성할 수 있다.
ex) a라는 멤버변수는 setter를 이용하여 데이터를 저장할 떄 50미만일 경우만 set할 수 있게 한다.
+ 객체의 무결성 보장 및 유효성검증을 위해 getter와 setter를 사용하는 것임.
getter는 프로퍼티(속성)을 복사하여 리턴하기 때문에 무결성을 지킬 수 있음.

<상속>
상속 : 부모 클래스를 상속받은 자식 클래스는 부모 클래스의 속성과 기능도 이용할 수 있다.
필요성 : 기존의 검증된 calss를 이용하여 빠르고 쉽게 새로운 class를 만들 수 있다.
예시 : 할아버지 클래스 (상속)-> 아버지 클래스 ->(상속) -> 자식 클래스(할아버지, 아버지 클래스의 속성, 메서드를 모두 활용가능)
※ JAVA에서는 단일 상속만 지원한다, (A라는 클래스가 여러개의 부모 클래스를 가질 수 없음)
※ 자식 클래스는 부모 클래스의 모든 자원을 사용할 수 있지만, private 접근자의 속성과 메서드는 사용할 수 없다.

<상속의 특징>
메서드 오버라이드 : 부모 클래스의 기능을 자식 클래스에서 재정의해서 사용하는 것.
※ 기본자료형처럼 클래스도 자료형이다.
※ 자식클래스를 new를 키워드를 이용해 초기화 할때 좌측부는 부모클래스여도 상관이 없다(부모클래스를 자식클래스를 상속받고 있기 때문에)
※ 모든 클래스의 최상위 클래스는 Object 클래스이다.
Object
  ↓
class..
super class : 상위 클래스를 호출 할 때 super 키워드를 이용한다.
ex) A클래스를 상속받은 B클래스에서 super 키워드를 이용하여 A클래스의 속성 or 메서드를 호출한다. / 반대의 경우 자기 자신의 속성, 메서드는 this 키워드를 이용


<내부 클래스와 익명클래스>
내부 클래스(inner class) : 클래스 안에 또 다른 클래스가 존재하는 것(두 클래스간의 멤버변수에 쉽게 접근이 가능해진다.)
익명 클래스(anonymous class) : 이름이 없는 클래스로 주로 메서드를 재정의 하는 목적으로 사용됨.
- 오직 하나의 객체만 생성할 수 있는 일회용 클래스, 생성자를 가질 수 없고, 조상클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용하여 정의하기 때문에
하나의 클래스를 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 하나의 클래스를 상속받거나 단하나의 인터페이스를 구현해야한다.


<인터페이스>
인터페이스(interface) : 클래스와 달리 객체를 생성할 수 는없으며, 클래스에서 구현이 강제되는 작업 명세서의 개념이다.
- 인터페이스있는 기능들을 클래스에서 구현한 뒤 객체를 생성하여 사용할 수 있다.
- 인터페이스를 사용하는 이유 : 다양한 이유가 있으나, 가장 큰 이유는 객체가 다양한 자료형(타입)을 가질 수 있기때문.
- 인터페이스를 사용하는 방법은 implements를 이용하여 사용할 수 있다 ex) public class Test implements interfaceA, interfaceB...
- 인터페이스는 다형성(다양한 형질을)을 가지게 구현할 수 있게 지원한다.
ex) 데이터타입이 장난감이라는 인터페이스가 있을 때, 로봇클래스, 비행기클래스가 장난감 인터페이스에서 구현해야 할 기능인(걷기, 날기, 싸우기등을 구현하여 사용할 수 있다)
장난감이라는 타입아래에 비행기, 자동차, 로봇 등등이 생성 될 수 있음, 인터페이스를 사용하지 않는 경우 비행기장난감, 자동차장난감, 로봇장난감 클래스를 만들어야 하는 상황이 생김(장난감이라는 기능은 똑같지만 매번 새롭게 만들어야함)

[예시]
물리적세계                 | 자바세계
컴퓨터                    | ZooKeeper
USB 포트	                 | Predator
하드디스크, 디지털카메라,... |	Tiger, Lion, Crocodile,...

다형성(폴리모피즘, Polymorphism) 예시 : 하나의 객체가 여러개의 자료형 타입을 가질 수 있는 것.
참조 : https://wikidocs.net/269


<추상클래스>
추상클래스 : 구체화되지 않은 멤버를 이용하여 만들어진 클래스
- 클래스의 공통된 부분을 뽑아서 별도의 클래스(추상클래스)로 만들어 놓고, 이것을 상속하여 사용
[특징]
1. 멤버변수를 가진다.
2. abstract 클래스를 상속하기 위해서는 extends 키워드를 사용한다.
3. abstract 메서드를 가지며, 상속한 클래스에서 반드시 구현해야 한다.
4. 일반 메서드도 가질 수 있다.
5. 일반 클래스와 마찬가지로 생성자도 가지고있다.


<인터페이스 vs 추상클래스>
공통점 : 추상 메서드를 가진다, 객체 생성이 불가하고 자료형(타입)으로 사용된다.
인터페이스 : 상수, 추상메서드만 가진다, 추상 메서드를 구현만 하도록 한다, 다형성을 지원한다
추상클래스 : 클래스가 가지는 모든 속성과 기능을 가진다, 추상메서드 구현 및 상속의 기능을 가진다, 단일 상속만 지원한다.
※ 사용도의 차이점 : 추상클래스는 IS ~ A (~이다(해야한다)) , 인터페이스는 HAS ~ A (~을 할 수 있는)
추상클래스의 사용 시기 : 상속 관계를 쭉 타고 올라갔을 때 같은 조상클래스까지를 상속하는데 기능까지 완벽하게 똑같이 필요한 경우(변할 염려가 없는)
인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라 갔을 때 조상클래스를 상속하는 것은 같으나, 같은 기능이 필요하지만, 추가적인 다른 기능도 필요할때(변화가 필요한 경우)


<람다식>
람다식 : 익명함수를 이용하여 익명 객체를 생성하기 위한 식
- 인터페이스를 클래스를 이용하지않고 람다식을 이용하여 생성해서 사용하는 것
- 기존 사용방식 : 인터페이스를 만들게 되면 어떤 클래스가 상속받아서 해당 클래스 안에서 인터페이스들의 메소드를 재정의(구현)하는 과정이 필요했으나,
람다식을 이용하면 그럴 필요없이 바로 재정의 후 사용이가능해짐.
- 람다식에서 매개변수가 1개이거나 타입이 같은경우 데이터 타입은 생략할 수 있다.
※ 람다식의 사용조건 : 인터페이스의 추상메소드일 것, 인터페이스가 단 1개의 추상메서드만 가지고 있어야할 것.
+ 람다식 전용 인터페이스를 관리하기 위한방법(1가지 추상메서드만 선언하도록) 하는 방법은 @FunctionalInterface 어노테이션(annotaion)을 이용하는 것임.
